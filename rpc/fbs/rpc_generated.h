// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RPC_FLATRPC_RPC_H_
#define FLATBUFFERS_GENERATED_RPC_FLATRPC_RPC_H_

#include "flatbuffers/flatbuffers.h"

namespace flatrpc {
namespace rpc {

struct Exception;
struct ExceptionBuilder;
struct ExceptionT;

struct RPC;
struct RPCBuilder;
struct RPCT;

bool operator==(const ExceptionT &lhs, const ExceptionT &rhs);
bool operator!=(const ExceptionT &lhs, const ExceptionT &rhs);
bool operator==(const RPCT &lhs, const RPCT &rhs);
bool operator!=(const RPCT &lhs, const RPCT &rhs);

inline const flatbuffers::TypeTable *ExceptionTypeTable();

inline const flatbuffers::TypeTable *RPCTypeTable();

enum class RPCType : int8_t {
  UNKNOWN = 0,
  CLIENT_REQ = 1,
  SERVER_REP = 2,
  SERVER_REQ = 4,
  CLIENT_REP = 8,
  MIN = UNKNOWN,
  MAX = CLIENT_REP
};

inline const RPCType (&EnumValuesRPCType())[5] {
  static const RPCType values[] = {
    RPCType::UNKNOWN,
    RPCType::CLIENT_REQ,
    RPCType::SERVER_REP,
    RPCType::SERVER_REQ,
    RPCType::CLIENT_REP
  };
  return values;
}

inline const char * const *EnumNamesRPCType() {
  static const char * const names[10] = {
    "UNKNOWN",
    "CLIENT_REQ",
    "SERVER_REP",
    "",
    "SERVER_REQ",
    "",
    "",
    "",
    "CLIENT_REP",
    nullptr
  };
  return names;
}

inline const char *EnumNameRPCType(RPCType e) {
  if (flatbuffers::IsOutRange(e, RPCType::UNKNOWN, RPCType::CLIENT_REP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRPCType()[index];
}

struct ExceptionT : public flatbuffers::NativeTable {
  typedef Exception TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "flatrpc.rpc.ExceptionT";
  }
  std::string what;
  ExceptionT() {
  }
};

inline bool operator==(const ExceptionT &lhs, const ExceptionT &rhs) {
  return
      (lhs.what == rhs.what);
}

inline bool operator!=(const ExceptionT &lhs, const ExceptionT &rhs) {
    return !(lhs == rhs);
}


struct Exception FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExceptionT NativeTableType;
  typedef ExceptionBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExceptionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "flatrpc.rpc.Exception";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHAT = 4
  };
  const flatbuffers::String *what() const {
    return GetPointer<const flatbuffers::String *>(VT_WHAT);
  }
  flatbuffers::String *mutable_what() {
    return GetPointer<flatbuffers::String *>(VT_WHAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WHAT) &&
           verifier.VerifyString(what()) &&
           verifier.EndTable();
  }
  ExceptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExceptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Exception> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExceptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExceptionBuilder {
  typedef Exception Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_what(flatbuffers::Offset<flatbuffers::String> what) {
    fbb_.AddOffset(Exception::VT_WHAT, what);
  }
  explicit ExceptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExceptionBuilder &operator=(const ExceptionBuilder &);
  flatbuffers::Offset<Exception> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exception>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exception> CreateException(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> what = 0) {
  ExceptionBuilder builder_(_fbb);
  builder_.add_what(what);
  return builder_.Finish();
}

struct Exception::Traits {
  using type = Exception;
  static auto constexpr Create = CreateException;
};

inline flatbuffers::Offset<Exception> CreateExceptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *what = nullptr) {
  auto what__ = what ? _fbb.CreateString(what) : 0;
  return flatrpc::rpc::CreateException(
      _fbb,
      what__);
}

flatbuffers::Offset<Exception> CreateException(flatbuffers::FlatBufferBuilder &_fbb, const ExceptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RPCT : public flatbuffers::NativeTable {
  typedef RPC TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "flatrpc.rpc.RPCT";
  }
  uint64_t requestId;
  flatrpc::rpc::RPCType type;
  std::string name;
  std::vector<int8_t> data;
  std::shared_ptr<flatrpc::rpc::ExceptionT> exception;
  RPCT()
      : requestId(0),
        type(flatrpc::rpc::RPCType::UNKNOWN) {
  }
};

inline bool operator==(const RPCT &lhs, const RPCT &rhs) {
  return
      (lhs.requestId == rhs.requestId) &&
      (lhs.type == rhs.type) &&
      (lhs.name == rhs.name) &&
      (lhs.data == rhs.data) &&
      (lhs.exception == rhs.exception);
}

inline bool operator!=(const RPCT &lhs, const RPCT &rhs) {
    return !(lhs == rhs);
}


struct RPC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RPCT NativeTableType;
  typedef RPCBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RPCTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "flatrpc.rpc.RPC";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTID = 4,
    VT_TYPE = 6,
    VT_NAME = 8,
    VT_DATA = 10,
    VT_EXCEPTION = 12
  };
  uint64_t requestId() const {
    return GetField<uint64_t>(VT_REQUESTID, 0);
  }
  bool mutate_requestId(uint64_t _requestId) {
    return SetField<uint64_t>(VT_REQUESTID, _requestId, 0);
  }
  flatrpc::rpc::RPCType type() const {
    return static_cast<flatrpc::rpc::RPCType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(flatrpc::rpc::RPCType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<int8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  const flatrpc::rpc::Exception *exception() const {
    return GetPointer<const flatrpc::rpc::Exception *>(VT_EXCEPTION);
  }
  flatrpc::rpc::Exception *mutable_exception() {
    return GetPointer<flatrpc::rpc::Exception *>(VT_EXCEPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_EXCEPTION) &&
           verifier.VerifyTable(exception()) &&
           verifier.EndTable();
  }
  RPCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RPCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RPC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RPCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RPCBuilder {
  typedef RPC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requestId(uint64_t requestId) {
    fbb_.AddElement<uint64_t>(RPC::VT_REQUESTID, requestId, 0);
  }
  void add_type(flatrpc::rpc::RPCType type) {
    fbb_.AddElement<int8_t>(RPC::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RPC::VT_NAME, name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(RPC::VT_DATA, data);
  }
  void add_exception(flatbuffers::Offset<flatrpc::rpc::Exception> exception) {
    fbb_.AddOffset(RPC::VT_EXCEPTION, exception);
  }
  explicit RPCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RPCBuilder &operator=(const RPCBuilder &);
  flatbuffers::Offset<RPC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RPC>(end);
    return o;
  }
};

inline flatbuffers::Offset<RPC> CreateRPC(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestId = 0,
    flatrpc::rpc::RPCType type = flatrpc::rpc::RPCType::UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0,
    flatbuffers::Offset<flatrpc::rpc::Exception> exception = 0) {
  RPCBuilder builder_(_fbb);
  builder_.add_requestId(requestId);
  builder_.add_exception(exception);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

struct RPC::Traits {
  using type = RPC;
  static auto constexpr Create = CreateRPC;
};

inline flatbuffers::Offset<RPC> CreateRPCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestId = 0,
    flatrpc::rpc::RPCType type = flatrpc::rpc::RPCType::UNKNOWN,
    const char *name = nullptr,
    const std::vector<int8_t> *data = nullptr,
    flatbuffers::Offset<flatrpc::rpc::Exception> exception = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return flatrpc::rpc::CreateRPC(
      _fbb,
      requestId,
      type,
      name__,
      data__,
      exception);
}

flatbuffers::Offset<RPC> CreateRPC(flatbuffers::FlatBufferBuilder &_fbb, const RPCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ExceptionT *Exception::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExceptionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Exception::UnPackTo(ExceptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = what(); if (_e) _o->what = _e->str(); }
}

inline flatbuffers::Offset<Exception> Exception::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExceptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateException(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Exception> CreateException(flatbuffers::FlatBufferBuilder &_fbb, const ExceptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExceptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _what = _o->what.empty() ? 0 : _fbb.CreateString(_o->what);
  return flatrpc::rpc::CreateException(
      _fbb,
      _what);
}

inline RPCT *RPC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RPCT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RPC::UnPackTo(RPCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = requestId(); _o->requestId = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
  { auto _e = exception(); if (_e) _o->exception = std::shared_ptr<flatrpc::rpc::ExceptionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<RPC> RPC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RPCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRPC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RPC> CreateRPC(flatbuffers::FlatBufferBuilder &_fbb, const RPCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RPCT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _requestId = _o->requestId;
  auto _type = _o->type;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _exception = _o->exception ? CreateException(_fbb, _o->exception.get(), _rehasher) : 0;
  return flatrpc::rpc::CreateRPC(
      _fbb,
      _requestId,
      _type,
      _name,
      _data,
      _exception);
}

inline const flatbuffers::TypeTable *RPCTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    flatrpc::rpc::RPCTypeTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8 };
  static const char * const names[] = {
    "UNKNOWN",
    "CLIENT_REQ",
    "SERVER_REP",
    "SERVER_REQ",
    "CLIENT_REP"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExceptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "what"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RPCTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    flatrpc::rpc::RPCTypeTypeTable,
    flatrpc::rpc::ExceptionTypeTable
  };
  static const char * const names[] = {
    "requestId",
    "type",
    "name",
    "data",
    "exception"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace rpc
}  // namespace flatrpc

#endif  // FLATBUFFERS_GENERATED_RPC_FLATRPC_RPC_H_
