// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_EXAMPLES_SIMPLE_H_
#define FLATBUFFERS_GENERATED_TYPES_EXAMPLES_SIMPLE_H_

#include "flatbuffers/flatbuffers.h"

namespace examples {
namespace simple {

struct BoolTable;
struct BoolTableBuilder;
struct BoolTableT;

struct ByteTable;
struct ByteTableBuilder;
struct ByteTableT;

struct UbyteTable;
struct UbyteTableBuilder;
struct UbyteTableT;

struct ShortTable;
struct ShortTableBuilder;
struct ShortTableT;

struct UshortTable;
struct UshortTableBuilder;
struct UshortTableT;

struct IntTable;
struct IntTableBuilder;
struct IntTableT;

struct UintTable;
struct UintTableBuilder;
struct UintTableT;

struct LongTable;
struct LongTableBuilder;
struct LongTableT;

struct UlongTable;
struct UlongTableBuilder;
struct UlongTableT;

struct FloatTable;
struct FloatTableBuilder;
struct FloatTableT;

struct DoubleTable;
struct DoubleTableBuilder;
struct DoubleTableT;

struct StringTable;
struct StringTableBuilder;
struct StringTableT;

struct Empty;
struct EmptyBuilder;
struct EmptyT;

bool operator==(const BoolTableT &lhs, const BoolTableT &rhs);
bool operator!=(const BoolTableT &lhs, const BoolTableT &rhs);
bool operator==(const ByteTableT &lhs, const ByteTableT &rhs);
bool operator!=(const ByteTableT &lhs, const ByteTableT &rhs);
bool operator==(const UbyteTableT &lhs, const UbyteTableT &rhs);
bool operator!=(const UbyteTableT &lhs, const UbyteTableT &rhs);
bool operator==(const ShortTableT &lhs, const ShortTableT &rhs);
bool operator!=(const ShortTableT &lhs, const ShortTableT &rhs);
bool operator==(const UshortTableT &lhs, const UshortTableT &rhs);
bool operator!=(const UshortTableT &lhs, const UshortTableT &rhs);
bool operator==(const IntTableT &lhs, const IntTableT &rhs);
bool operator!=(const IntTableT &lhs, const IntTableT &rhs);
bool operator==(const UintTableT &lhs, const UintTableT &rhs);
bool operator!=(const UintTableT &lhs, const UintTableT &rhs);
bool operator==(const LongTableT &lhs, const LongTableT &rhs);
bool operator!=(const LongTableT &lhs, const LongTableT &rhs);
bool operator==(const UlongTableT &lhs, const UlongTableT &rhs);
bool operator!=(const UlongTableT &lhs, const UlongTableT &rhs);
bool operator==(const FloatTableT &lhs, const FloatTableT &rhs);
bool operator!=(const FloatTableT &lhs, const FloatTableT &rhs);
bool operator==(const DoubleTableT &lhs, const DoubleTableT &rhs);
bool operator!=(const DoubleTableT &lhs, const DoubleTableT &rhs);
bool operator==(const StringTableT &lhs, const StringTableT &rhs);
bool operator!=(const StringTableT &lhs, const StringTableT &rhs);
bool operator==(const EmptyT &lhs, const EmptyT &rhs);
bool operator!=(const EmptyT &lhs, const EmptyT &rhs);

inline const flatbuffers::TypeTable *BoolTableTypeTable();

inline const flatbuffers::TypeTable *ByteTableTypeTable();

inline const flatbuffers::TypeTable *UbyteTableTypeTable();

inline const flatbuffers::TypeTable *ShortTableTypeTable();

inline const flatbuffers::TypeTable *UshortTableTypeTable();

inline const flatbuffers::TypeTable *IntTableTypeTable();

inline const flatbuffers::TypeTable *UintTableTypeTable();

inline const flatbuffers::TypeTable *LongTableTypeTable();

inline const flatbuffers::TypeTable *UlongTableTypeTable();

inline const flatbuffers::TypeTable *FloatTableTypeTable();

inline const flatbuffers::TypeTable *DoubleTableTypeTable();

inline const flatbuffers::TypeTable *StringTableTypeTable();

inline const flatbuffers::TypeTable *EmptyTypeTable();

struct BoolTableT : public flatbuffers::NativeTable {
  typedef BoolTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.BoolTableT";
  }
  bool bool_field;
  BoolTableT()
      : bool_field(false) {
  }
};

inline bool operator==(const BoolTableT &lhs, const BoolTableT &rhs) {
  return
      (lhs.bool_field == rhs.bool_field);
}

inline bool operator!=(const BoolTableT &lhs, const BoolTableT &rhs) {
    return !(lhs == rhs);
}


struct BoolTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoolTableT NativeTableType;
  typedef BoolTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BoolTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.BoolTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOOL_FIELD = 4
  };
  bool bool_field() const {
    return GetField<uint8_t>(VT_BOOL_FIELD, 0) != 0;
  }
  bool mutate_bool_field(bool _bool_field) {
    return SetField<uint8_t>(VT_BOOL_FIELD, static_cast<uint8_t>(_bool_field), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BOOL_FIELD) &&
           verifier.EndTable();
  }
  BoolTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoolTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BoolTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoolTableBuilder {
  typedef BoolTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bool_field(bool bool_field) {
    fbb_.AddElement<uint8_t>(BoolTable::VT_BOOL_FIELD, static_cast<uint8_t>(bool_field), 0);
  }
  explicit BoolTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolTableBuilder &operator=(const BoolTableBuilder &);
  flatbuffers::Offset<BoolTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoolTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoolTable> CreateBoolTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bool_field = false) {
  BoolTableBuilder builder_(_fbb);
  builder_.add_bool_field(bool_field);
  return builder_.Finish();
}

struct BoolTable::Traits {
  using type = BoolTable;
  static auto constexpr Create = CreateBoolTable;
};

flatbuffers::Offset<BoolTable> CreateBoolTable(flatbuffers::FlatBufferBuilder &_fbb, const BoolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ByteTableT : public flatbuffers::NativeTable {
  typedef ByteTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.ByteTableT";
  }
  int8_t byte_field;
  ByteTableT()
      : byte_field(0) {
  }
};

inline bool operator==(const ByteTableT &lhs, const ByteTableT &rhs) {
  return
      (lhs.byte_field == rhs.byte_field);
}

inline bool operator!=(const ByteTableT &lhs, const ByteTableT &rhs) {
    return !(lhs == rhs);
}


struct ByteTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ByteTableT NativeTableType;
  typedef ByteTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ByteTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.ByteTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTE_FIELD = 4
  };
  int8_t byte_field() const {
    return GetField<int8_t>(VT_BYTE_FIELD, 0);
  }
  bool mutate_byte_field(int8_t _byte_field) {
    return SetField<int8_t>(VT_BYTE_FIELD, _byte_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BYTE_FIELD) &&
           verifier.EndTable();
  }
  ByteTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ByteTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ByteTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ByteTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ByteTableBuilder {
  typedef ByteTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_byte_field(int8_t byte_field) {
    fbb_.AddElement<int8_t>(ByteTable::VT_BYTE_FIELD, byte_field, 0);
  }
  explicit ByteTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ByteTableBuilder &operator=(const ByteTableBuilder &);
  flatbuffers::Offset<ByteTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ByteTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ByteTable> CreateByteTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t byte_field = 0) {
  ByteTableBuilder builder_(_fbb);
  builder_.add_byte_field(byte_field);
  return builder_.Finish();
}

struct ByteTable::Traits {
  using type = ByteTable;
  static auto constexpr Create = CreateByteTable;
};

flatbuffers::Offset<ByteTable> CreateByteTable(flatbuffers::FlatBufferBuilder &_fbb, const ByteTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UbyteTableT : public flatbuffers::NativeTable {
  typedef UbyteTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UbyteTableT";
  }
  uint8_t ubyte_field;
  UbyteTableT()
      : ubyte_field(0) {
  }
};

inline bool operator==(const UbyteTableT &lhs, const UbyteTableT &rhs) {
  return
      (lhs.ubyte_field == rhs.ubyte_field);
}

inline bool operator!=(const UbyteTableT &lhs, const UbyteTableT &rhs) {
    return !(lhs == rhs);
}


struct UbyteTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UbyteTableT NativeTableType;
  typedef UbyteTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UbyteTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UbyteTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UBYTE_FIELD = 4
  };
  uint8_t ubyte_field() const {
    return GetField<uint8_t>(VT_UBYTE_FIELD, 0);
  }
  bool mutate_ubyte_field(uint8_t _ubyte_field) {
    return SetField<uint8_t>(VT_UBYTE_FIELD, _ubyte_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UBYTE_FIELD) &&
           verifier.EndTable();
  }
  UbyteTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UbyteTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UbyteTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UbyteTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UbyteTableBuilder {
  typedef UbyteTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ubyte_field(uint8_t ubyte_field) {
    fbb_.AddElement<uint8_t>(UbyteTable::VT_UBYTE_FIELD, ubyte_field, 0);
  }
  explicit UbyteTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UbyteTableBuilder &operator=(const UbyteTableBuilder &);
  flatbuffers::Offset<UbyteTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UbyteTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UbyteTable> CreateUbyteTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t ubyte_field = 0) {
  UbyteTableBuilder builder_(_fbb);
  builder_.add_ubyte_field(ubyte_field);
  return builder_.Finish();
}

struct UbyteTable::Traits {
  using type = UbyteTable;
  static auto constexpr Create = CreateUbyteTable;
};

flatbuffers::Offset<UbyteTable> CreateUbyteTable(flatbuffers::FlatBufferBuilder &_fbb, const UbyteTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShortTableT : public flatbuffers::NativeTable {
  typedef ShortTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.ShortTableT";
  }
  int16_t short_field;
  ShortTableT()
      : short_field(0) {
  }
};

inline bool operator==(const ShortTableT &lhs, const ShortTableT &rhs) {
  return
      (lhs.short_field == rhs.short_field);
}

inline bool operator!=(const ShortTableT &lhs, const ShortTableT &rhs) {
    return !(lhs == rhs);
}


struct ShortTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShortTableT NativeTableType;
  typedef ShortTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShortTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.ShortTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORT_FIELD = 4
  };
  int16_t short_field() const {
    return GetField<int16_t>(VT_SHORT_FIELD, 0);
  }
  bool mutate_short_field(int16_t _short_field) {
    return SetField<int16_t>(VT_SHORT_FIELD, _short_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_SHORT_FIELD) &&
           verifier.EndTable();
  }
  ShortTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShortTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShortTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShortTableBuilder {
  typedef ShortTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_short_field(int16_t short_field) {
    fbb_.AddElement<int16_t>(ShortTable::VT_SHORT_FIELD, short_field, 0);
  }
  explicit ShortTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShortTableBuilder &operator=(const ShortTableBuilder &);
  flatbuffers::Offset<ShortTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShortTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShortTable> CreateShortTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t short_field = 0) {
  ShortTableBuilder builder_(_fbb);
  builder_.add_short_field(short_field);
  return builder_.Finish();
}

struct ShortTable::Traits {
  using type = ShortTable;
  static auto constexpr Create = CreateShortTable;
};

flatbuffers::Offset<ShortTable> CreateShortTable(flatbuffers::FlatBufferBuilder &_fbb, const ShortTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UshortTableT : public flatbuffers::NativeTable {
  typedef UshortTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UshortTableT";
  }
  uint16_t ushort_field;
  UshortTableT()
      : ushort_field(0) {
  }
};

inline bool operator==(const UshortTableT &lhs, const UshortTableT &rhs) {
  return
      (lhs.ushort_field == rhs.ushort_field);
}

inline bool operator!=(const UshortTableT &lhs, const UshortTableT &rhs) {
    return !(lhs == rhs);
}


struct UshortTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UshortTableT NativeTableType;
  typedef UshortTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UshortTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UshortTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USHORT_FIELD = 4
  };
  uint16_t ushort_field() const {
    return GetField<uint16_t>(VT_USHORT_FIELD, 0);
  }
  bool mutate_ushort_field(uint16_t _ushort_field) {
    return SetField<uint16_t>(VT_USHORT_FIELD, _ushort_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_USHORT_FIELD) &&
           verifier.EndTable();
  }
  UshortTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UshortTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UshortTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UshortTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UshortTableBuilder {
  typedef UshortTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ushort_field(uint16_t ushort_field) {
    fbb_.AddElement<uint16_t>(UshortTable::VT_USHORT_FIELD, ushort_field, 0);
  }
  explicit UshortTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UshortTableBuilder &operator=(const UshortTableBuilder &);
  flatbuffers::Offset<UshortTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UshortTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UshortTable> CreateUshortTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t ushort_field = 0) {
  UshortTableBuilder builder_(_fbb);
  builder_.add_ushort_field(ushort_field);
  return builder_.Finish();
}

struct UshortTable::Traits {
  using type = UshortTable;
  static auto constexpr Create = CreateUshortTable;
};

flatbuffers::Offset<UshortTable> CreateUshortTable(flatbuffers::FlatBufferBuilder &_fbb, const UshortTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntTableT : public flatbuffers::NativeTable {
  typedef IntTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.IntTableT";
  }
  int32_t int_field;
  IntTableT()
      : int_field(0) {
  }
};

inline bool operator==(const IntTableT &lhs, const IntTableT &rhs) {
  return
      (lhs.int_field == rhs.int_field);
}

inline bool operator!=(const IntTableT &lhs, const IntTableT &rhs) {
    return !(lhs == rhs);
}


struct IntTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntTableT NativeTableType;
  typedef IntTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.IntTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT_FIELD = 4
  };
  int32_t int_field() const {
    return GetField<int32_t>(VT_INT_FIELD, 0);
  }
  bool mutate_int_field(int32_t _int_field) {
    return SetField<int32_t>(VT_INT_FIELD, _int_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INT_FIELD) &&
           verifier.EndTable();
  }
  IntTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IntTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntTableBuilder {
  typedef IntTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_int_field(int32_t int_field) {
    fbb_.AddElement<int32_t>(IntTable::VT_INT_FIELD, int_field, 0);
  }
  explicit IntTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntTableBuilder &operator=(const IntTableBuilder &);
  flatbuffers::Offset<IntTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntTable> CreateIntTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t int_field = 0) {
  IntTableBuilder builder_(_fbb);
  builder_.add_int_field(int_field);
  return builder_.Finish();
}

struct IntTable::Traits {
  using type = IntTable;
  static auto constexpr Create = CreateIntTable;
};

flatbuffers::Offset<IntTable> CreateIntTable(flatbuffers::FlatBufferBuilder &_fbb, const IntTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UintTableT : public flatbuffers::NativeTable {
  typedef UintTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UintTableT";
  }
  uint32_t uint_field;
  UintTableT()
      : uint_field(0) {
  }
};

inline bool operator==(const UintTableT &lhs, const UintTableT &rhs) {
  return
      (lhs.uint_field == rhs.uint_field);
}

inline bool operator!=(const UintTableT &lhs, const UintTableT &rhs) {
    return !(lhs == rhs);
}


struct UintTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UintTableT NativeTableType;
  typedef UintTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UintTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UintTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UINT_FIELD = 4
  };
  uint32_t uint_field() const {
    return GetField<uint32_t>(VT_UINT_FIELD, 0);
  }
  bool mutate_uint_field(uint32_t _uint_field) {
    return SetField<uint32_t>(VT_UINT_FIELD, _uint_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UINT_FIELD) &&
           verifier.EndTable();
  }
  UintTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UintTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UintTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UintTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UintTableBuilder {
  typedef UintTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uint_field(uint32_t uint_field) {
    fbb_.AddElement<uint32_t>(UintTable::VT_UINT_FIELD, uint_field, 0);
  }
  explicit UintTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UintTableBuilder &operator=(const UintTableBuilder &);
  flatbuffers::Offset<UintTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UintTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UintTable> CreateUintTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uint_field = 0) {
  UintTableBuilder builder_(_fbb);
  builder_.add_uint_field(uint_field);
  return builder_.Finish();
}

struct UintTable::Traits {
  using type = UintTable;
  static auto constexpr Create = CreateUintTable;
};

flatbuffers::Offset<UintTable> CreateUintTable(flatbuffers::FlatBufferBuilder &_fbb, const UintTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LongTableT : public flatbuffers::NativeTable {
  typedef LongTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.LongTableT";
  }
  int64_t long_field;
  LongTableT()
      : long_field(0) {
  }
};

inline bool operator==(const LongTableT &lhs, const LongTableT &rhs) {
  return
      (lhs.long_field == rhs.long_field);
}

inline bool operator!=(const LongTableT &lhs, const LongTableT &rhs) {
    return !(lhs == rhs);
}


struct LongTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LongTableT NativeTableType;
  typedef LongTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LongTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.LongTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONG_FIELD = 4
  };
  int64_t long_field() const {
    return GetField<int64_t>(VT_LONG_FIELD, 0);
  }
  bool mutate_long_field(int64_t _long_field) {
    return SetField<int64_t>(VT_LONG_FIELD, _long_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LONG_FIELD) &&
           verifier.EndTable();
  }
  LongTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LongTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LongTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LongTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LongTableBuilder {
  typedef LongTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_long_field(int64_t long_field) {
    fbb_.AddElement<int64_t>(LongTable::VT_LONG_FIELD, long_field, 0);
  }
  explicit LongTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LongTableBuilder &operator=(const LongTableBuilder &);
  flatbuffers::Offset<LongTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LongTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<LongTable> CreateLongTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t long_field = 0) {
  LongTableBuilder builder_(_fbb);
  builder_.add_long_field(long_field);
  return builder_.Finish();
}

struct LongTable::Traits {
  using type = LongTable;
  static auto constexpr Create = CreateLongTable;
};

flatbuffers::Offset<LongTable> CreateLongTable(flatbuffers::FlatBufferBuilder &_fbb, const LongTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UlongTableT : public flatbuffers::NativeTable {
  typedef UlongTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UlongTableT";
  }
  uint64_t ulong_field;
  UlongTableT()
      : ulong_field(0) {
  }
};

inline bool operator==(const UlongTableT &lhs, const UlongTableT &rhs) {
  return
      (lhs.ulong_field == rhs.ulong_field);
}

inline bool operator!=(const UlongTableT &lhs, const UlongTableT &rhs) {
    return !(lhs == rhs);
}


struct UlongTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UlongTableT NativeTableType;
  typedef UlongTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UlongTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.UlongTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ULONG_FIELD = 4
  };
  uint64_t ulong_field() const {
    return GetField<uint64_t>(VT_ULONG_FIELD, 0);
  }
  bool mutate_ulong_field(uint64_t _ulong_field) {
    return SetField<uint64_t>(VT_ULONG_FIELD, _ulong_field, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ULONG_FIELD) &&
           verifier.EndTable();
  }
  UlongTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UlongTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UlongTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UlongTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UlongTableBuilder {
  typedef UlongTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ulong_field(uint64_t ulong_field) {
    fbb_.AddElement<uint64_t>(UlongTable::VT_ULONG_FIELD, ulong_field, 0);
  }
  explicit UlongTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UlongTableBuilder &operator=(const UlongTableBuilder &);
  flatbuffers::Offset<UlongTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UlongTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<UlongTable> CreateUlongTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ulong_field = 0) {
  UlongTableBuilder builder_(_fbb);
  builder_.add_ulong_field(ulong_field);
  return builder_.Finish();
}

struct UlongTable::Traits {
  using type = UlongTable;
  static auto constexpr Create = CreateUlongTable;
};

flatbuffers::Offset<UlongTable> CreateUlongTable(flatbuffers::FlatBufferBuilder &_fbb, const UlongTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatTableT : public flatbuffers::NativeTable {
  typedef FloatTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.FloatTableT";
  }
  float float_field;
  FloatTableT()
      : float_field(0.0f) {
  }
};

inline bool operator==(const FloatTableT &lhs, const FloatTableT &rhs) {
  return
      (lhs.float_field == rhs.float_field);
}

inline bool operator!=(const FloatTableT &lhs, const FloatTableT &rhs) {
    return !(lhs == rhs);
}


struct FloatTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatTableT NativeTableType;
  typedef FloatTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloatTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.FloatTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOAT_FIELD = 4
  };
  float float_field() const {
    return GetField<float>(VT_FLOAT_FIELD, 0.0f);
  }
  bool mutate_float_field(float _float_field) {
    return SetField<float>(VT_FLOAT_FIELD, _float_field, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FLOAT_FIELD) &&
           verifier.EndTable();
  }
  FloatTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloatTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatTableBuilder {
  typedef FloatTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_float_field(float float_field) {
    fbb_.AddElement<float>(FloatTable::VT_FLOAT_FIELD, float_field, 0.0f);
  }
  explicit FloatTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatTableBuilder &operator=(const FloatTableBuilder &);
  flatbuffers::Offset<FloatTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatTable> CreateFloatTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    float float_field = 0.0f) {
  FloatTableBuilder builder_(_fbb);
  builder_.add_float_field(float_field);
  return builder_.Finish();
}

struct FloatTable::Traits {
  using type = FloatTable;
  static auto constexpr Create = CreateFloatTable;
};

flatbuffers::Offset<FloatTable> CreateFloatTable(flatbuffers::FlatBufferBuilder &_fbb, const FloatTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DoubleTableT : public flatbuffers::NativeTable {
  typedef DoubleTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.DoubleTableT";
  }
  double double_field;
  DoubleTableT()
      : double_field(0.0) {
  }
};

inline bool operator==(const DoubleTableT &lhs, const DoubleTableT &rhs) {
  return
      (lhs.double_field == rhs.double_field);
}

inline bool operator!=(const DoubleTableT &lhs, const DoubleTableT &rhs) {
    return !(lhs == rhs);
}


struct DoubleTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleTableT NativeTableType;
  typedef DoubleTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DoubleTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.DoubleTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOUBLE_FIELD = 4
  };
  double double_field() const {
    return GetField<double>(VT_DOUBLE_FIELD, 0.0);
  }
  bool mutate_double_field(double _double_field) {
    return SetField<double>(VT_DOUBLE_FIELD, _double_field, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DOUBLE_FIELD) &&
           verifier.EndTable();
  }
  DoubleTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DoubleTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DoubleTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DoubleTableBuilder {
  typedef DoubleTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_double_field(double double_field) {
    fbb_.AddElement<double>(DoubleTable::VT_DOUBLE_FIELD, double_field, 0.0);
  }
  explicit DoubleTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleTableBuilder &operator=(const DoubleTableBuilder &);
  flatbuffers::Offset<DoubleTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleTable> CreateDoubleTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    double double_field = 0.0) {
  DoubleTableBuilder builder_(_fbb);
  builder_.add_double_field(double_field);
  return builder_.Finish();
}

struct DoubleTable::Traits {
  using type = DoubleTable;
  static auto constexpr Create = CreateDoubleTable;
};

flatbuffers::Offset<DoubleTable> CreateDoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const DoubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringTableT : public flatbuffers::NativeTable {
  typedef StringTable TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.StringTableT";
  }
  std::string string_field;
  StringTableT() {
  }
};

inline bool operator==(const StringTableT &lhs, const StringTableT &rhs) {
  return
      (lhs.string_field == rhs.string_field);
}

inline bool operator!=(const StringTableT &lhs, const StringTableT &rhs) {
    return !(lhs == rhs);
}


struct StringTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringTableT NativeTableType;
  typedef StringTableBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.StringTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRING_FIELD = 4
  };
  const flatbuffers::String *string_field() const {
    return GetPointer<const flatbuffers::String *>(VT_STRING_FIELD);
  }
  flatbuffers::String *mutable_string_field() {
    return GetPointer<flatbuffers::String *>(VT_STRING_FIELD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRING_FIELD) &&
           verifier.VerifyString(string_field()) &&
           verifier.EndTable();
  }
  StringTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StringTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringTableBuilder {
  typedef StringTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_string_field(flatbuffers::Offset<flatbuffers::String> string_field) {
    fbb_.AddOffset(StringTable::VT_STRING_FIELD, string_field);
  }
  explicit StringTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringTableBuilder &operator=(const StringTableBuilder &);
  flatbuffers::Offset<StringTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringTable> CreateStringTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> string_field = 0) {
  StringTableBuilder builder_(_fbb);
  builder_.add_string_field(string_field);
  return builder_.Finish();
}

struct StringTable::Traits {
  using type = StringTable;
  static auto constexpr Create = CreateStringTable;
};

inline flatbuffers::Offset<StringTable> CreateStringTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *string_field = nullptr) {
  auto string_field__ = string_field ? _fbb.CreateString(string_field) : 0;
  return examples::simple::CreateStringTable(
      _fbb,
      string_field__);
}

flatbuffers::Offset<StringTable> CreateStringTable(flatbuffers::FlatBufferBuilder &_fbb, const StringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmptyT : public flatbuffers::NativeTable {
  typedef Empty TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.EmptyT";
  }
  EmptyT() {
  }
};

inline bool operator==(const EmptyT &, const EmptyT &) {
  return true;
}

inline bool operator!=(const EmptyT &lhs, const EmptyT &rhs) {
    return !(lhs == rhs);
}


struct Empty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyT NativeTableType;
  typedef EmptyBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmptyTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "examples.simple.Empty";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EmptyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmptyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Empty> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmptyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmptyBuilder {
  typedef Empty Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmptyBuilder &operator=(const EmptyBuilder &);
  flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline flatbuffers::Offset<Empty> CreateEmpty(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Empty::Traits {
  using type = Empty;
  static auto constexpr Create = CreateEmpty;
};

flatbuffers::Offset<Empty> CreateEmpty(flatbuffers::FlatBufferBuilder &_fbb, const EmptyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BoolTableT *BoolTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BoolTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BoolTable::UnPackTo(BoolTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bool_field(); _o->bool_field = _e; }
}

inline flatbuffers::Offset<BoolTable> BoolTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoolTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BoolTable> CreateBoolTable(flatbuffers::FlatBufferBuilder &_fbb, const BoolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BoolTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bool_field = _o->bool_field;
  return examples::simple::CreateBoolTable(
      _fbb,
      _bool_field);
}

inline ByteTableT *ByteTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ByteTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ByteTable::UnPackTo(ByteTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = byte_field(); _o->byte_field = _e; }
}

inline flatbuffers::Offset<ByteTable> ByteTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ByteTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateByteTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ByteTable> CreateByteTable(flatbuffers::FlatBufferBuilder &_fbb, const ByteTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ByteTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _byte_field = _o->byte_field;
  return examples::simple::CreateByteTable(
      _fbb,
      _byte_field);
}

inline UbyteTableT *UbyteTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UbyteTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UbyteTable::UnPackTo(UbyteTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ubyte_field(); _o->ubyte_field = _e; }
}

inline flatbuffers::Offset<UbyteTable> UbyteTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UbyteTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUbyteTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UbyteTable> CreateUbyteTable(flatbuffers::FlatBufferBuilder &_fbb, const UbyteTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UbyteTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ubyte_field = _o->ubyte_field;
  return examples::simple::CreateUbyteTable(
      _fbb,
      _ubyte_field);
}

inline ShortTableT *ShortTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShortTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ShortTable::UnPackTo(ShortTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = short_field(); _o->short_field = _e; }
}

inline flatbuffers::Offset<ShortTable> ShortTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShortTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShortTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShortTable> CreateShortTable(flatbuffers::FlatBufferBuilder &_fbb, const ShortTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShortTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _short_field = _o->short_field;
  return examples::simple::CreateShortTable(
      _fbb,
      _short_field);
}

inline UshortTableT *UshortTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UshortTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UshortTable::UnPackTo(UshortTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ushort_field(); _o->ushort_field = _e; }
}

inline flatbuffers::Offset<UshortTable> UshortTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UshortTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUshortTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UshortTable> CreateUshortTable(flatbuffers::FlatBufferBuilder &_fbb, const UshortTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UshortTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ushort_field = _o->ushort_field;
  return examples::simple::CreateUshortTable(
      _fbb,
      _ushort_field);
}

inline IntTableT *IntTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IntTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IntTable::UnPackTo(IntTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = int_field(); _o->int_field = _e; }
}

inline flatbuffers::Offset<IntTable> IntTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IntTable> CreateIntTable(flatbuffers::FlatBufferBuilder &_fbb, const IntTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IntTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _int_field = _o->int_field;
  return examples::simple::CreateIntTable(
      _fbb,
      _int_field);
}

inline UintTableT *UintTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UintTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UintTable::UnPackTo(UintTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uint_field(); _o->uint_field = _e; }
}

inline flatbuffers::Offset<UintTable> UintTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UintTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUintTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UintTable> CreateUintTable(flatbuffers::FlatBufferBuilder &_fbb, const UintTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UintTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uint_field = _o->uint_field;
  return examples::simple::CreateUintTable(
      _fbb,
      _uint_field);
}

inline LongTableT *LongTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LongTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LongTable::UnPackTo(LongTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = long_field(); _o->long_field = _e; }
}

inline flatbuffers::Offset<LongTable> LongTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LongTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLongTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LongTable> CreateLongTable(flatbuffers::FlatBufferBuilder &_fbb, const LongTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LongTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _long_field = _o->long_field;
  return examples::simple::CreateLongTable(
      _fbb,
      _long_field);
}

inline UlongTableT *UlongTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UlongTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UlongTable::UnPackTo(UlongTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ulong_field(); _o->ulong_field = _e; }
}

inline flatbuffers::Offset<UlongTable> UlongTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UlongTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUlongTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UlongTable> CreateUlongTable(flatbuffers::FlatBufferBuilder &_fbb, const UlongTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UlongTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ulong_field = _o->ulong_field;
  return examples::simple::CreateUlongTable(
      _fbb,
      _ulong_field);
}

inline FloatTableT *FloatTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FloatTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FloatTable::UnPackTo(FloatTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = float_field(); _o->float_field = _e; }
}

inline flatbuffers::Offset<FloatTable> FloatTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloatTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloatTable> CreateFloatTable(flatbuffers::FlatBufferBuilder &_fbb, const FloatTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloatTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _float_field = _o->float_field;
  return examples::simple::CreateFloatTable(
      _fbb,
      _float_field);
}

inline DoubleTableT *DoubleTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DoubleTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DoubleTable::UnPackTo(DoubleTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = double_field(); _o->double_field = _e; }
}

inline flatbuffers::Offset<DoubleTable> DoubleTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDoubleTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DoubleTable> CreateDoubleTable(flatbuffers::FlatBufferBuilder &_fbb, const DoubleTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DoubleTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _double_field = _o->double_field;
  return examples::simple::CreateDoubleTable(
      _fbb,
      _double_field);
}

inline StringTableT *StringTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StringTableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StringTable::UnPackTo(StringTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = string_field(); if (_e) _o->string_field = _e->str(); }
}

inline flatbuffers::Offset<StringTable> StringTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringTable> CreateStringTable(flatbuffers::FlatBufferBuilder &_fbb, const StringTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StringTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _string_field = _o->string_field.empty() ? 0 : _fbb.CreateString(_o->string_field);
  return examples::simple::CreateStringTable(
      _fbb,
      _string_field);
}

inline EmptyT *Empty::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EmptyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Empty::UnPackTo(EmptyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Empty> Empty::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmptyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmpty(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Empty> CreateEmpty(flatbuffers::FlatBufferBuilder &_fbb, const EmptyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmptyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return examples::simple::CreateEmpty(
      _fbb);
}

inline const flatbuffers::TypeTable *BoolTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "bool_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ByteTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, -1 }
  };
  static const char * const names[] = {
    "byte_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UbyteTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "ubyte_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShortTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const char * const names[] = {
    "short_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UshortTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "ushort_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "int_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UintTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "uint_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LongTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "long_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UlongTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "ulong_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloatTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "float_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DoubleTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "double_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StringTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "string_field"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmptyTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace simple
}  // namespace examples

#endif  // FLATBUFFERS_GENERATED_TYPES_EXAMPLES_SIMPLE_H_
